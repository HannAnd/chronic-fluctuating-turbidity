---
title: "Fluctuating Turbidity Rolling Averages"
author: "Hannah Anderson"
date: "2023-01-30"
output: pdf_document
---

## Intro

This document goes hand in hand with the RMarkdown file "Fluctuating Turbidity
Data Conversion" (fluctuating_turbidity_data_conversion.Rmd). It will
eventually become a part of that file, but for troubleshooting's sake I will
be working on them separately for now.

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#setting the working directory
knitr::opts_knit$set(root.dir = "D://2 Day Mini Kaolin Turb Flux Experiment/testing")
#library(plyr)
library(tidyverse)
library(data.table)
#the number of fish per group
fish = 4

```

## Reading in the files

```{r file read in, include = FALSE, message = FALSE}
#reading in the file names into a list
filelist <- list.files(pattern = "*.csv")
#from list of files, creating a list of dataframes from each file
#excluding the columns that are either empty or don't contain data we're using
fishlist <- lapply(filelist, read_csv, col_select = c(3:4, 6:8))
#replacing the inf TRex uses in place of NAs with NAs
Inf2NA <- function(v) replace(v, is.infinite(v), NA)
fishlist <- lapply(fishlist, function(d) replace(d, TRUE, sapply(d, Inf2NA)))
#colnames(workframe) <- c("tankID", "recording", "rolling_speed")
```

## Processing the files

```{r loop, include = FALSE, message = FALSE}

i = 1
#across the whole file list
for (k in 1:(length(filelist)/fish)) {
  fourfish <- fishlist[i:(i+(fish-1))]
  i = i+fish
  #determining the last frame of a video by taking the largest frame value
  #from all of the fish datafiles
  maxframe <- max(fourfish[[1]][,"frame"])
  
  #creating a dataframe with as many frames as the processed video and filling
  #all non-frame columns with NAs
  dfNA <- data.frame(frame = 0:maxframe, fish_detected = NA, angle = NA,
                     X = NA, Y = NA)
  
  #across one video of files
  for (z in 1:fish) {
    #finding the frame the fish datafile starts on
    minfish <- min(fourfish[[z]][,"frame"])
    #adding the NA rows from dfNA to the top of a file if its "frames" column
    #starts later than frame 0
    if (minfish > 0) {
      fourfish[[z]] <- rbind(dfNA[1:(minfish),], fourfish[[z]])
    }
    #finding the fame the fish datafile ends on
    maxfish <- max(fourfish[[z]][,"frame"])
    #adding the NA rows from dfNA to the bottom of a file if its "frames" column
    #ends before the end of the video (the last frame of the longest datafile)
    #+1 for the same reason as above with minimum frames, +2 to avoid
    #duplicating the last frame
    if (maxfish < maxframe) {
      #+2 to account for both the first frame being zero instead of 1 and to
      #avoid duplicating the last frame, +1 to account for the first frame being
      #a zero
      fourfish[[z]] <- rbind(fourfish[[z]], dfNA[(maxfish+2):(maxframe+1),])
      #test <- rbind(fourfish[[z]], dfNA[(maxfish+2):(maxframe+1),])
    }
    #a for loop inside a for loop inside a for loop...
    #this is starting to feel unnecessarily complicated. Oh well.
      
    #a dataframe to hold the distance values (calculated) and the polarity
    #values (exported from TRex, in radians)
    distpol <- data.frame(matrix(nrow = nrow(fourfish[[z]][,1]), ncol = 3))
    colnames(distpol) <- c("frame", "distance", "polarity")
    distpol$frame <- fourfish[[z]][,"frame"]      #need to change to number value  ####
    distpol$polarity <- fourfish[[z]][,"angle"]   #rather than column name         ####
    distpol <- as.data.frame(distpol)
    
    #within one fish's file
    #calculating the distance values
    for (t in 1:(maxframe-1)) {
    #Mistake here
    #What we need is a total distance moved across three seconds
      #That does NOT mean finding the distance between where the fish was at
      #the start of second one and where the fish was at the end of second three
      #It means finding the distance moved between every frame of those total
      #90 seconds
      distance <- sqrt(((fourfish[[z]][(t+1),"X"]) - (fourfish[[z]][t,"X"]))^2 +
                      ((fourfish[[z]][(t+1),"Y"]) - (fourfish[[z]][t,"Y"]))^2)
      distpol$distance[t+1] <- distance
    }
    
    #within one fish's file
    #calculating the moving average of speed (we'll get to the others later)
    rollvals <- data.frame(matrix(nrow = floor(maxframe/30)), ncol = 2)
    colnames(rollvals) <- c("time_s", "speed")
    #the time step window (amount of time before and after a time step) being
    #used in the moving average
    #our videos are in ~30 frames per second (29.7 frames)
    timew = 30    #window = 1 second
    timestep = 1
    
    #calculating iterations by taking the total number of frames in a file,
    #dividing by the time window and rounding down to the nearest whole window.
    #Then subtract two for the time windows that can't be calculated at the
    #beginning and end of the file due to the nature of moving averages
    
    #rollspeed <- rollmean(distpol$distance, 90)
    rollpol <- rollapply(distpol$polarity, width = 90, FUN = mean, by = 1, fill = NA, partial = TRUE)
    
    
    #for (m in 1:(floor(maxframe/timew)-2)) {
      #rollspeed <- sum(distpol[(timestep):((timestep-1)+(timew*3)),"distance"])
      #rolltest <- colSums(distpol[1:90,"distance"])
    #}
      
    }
  }
  
  
  
  #combining together should only be happening after all of the other steps
  #of calculating the rolling averages have already happened
  ##x4 <- merge(x  = x1, y = x2, all = TRUE)
  #must be un-commented for groups of 4 fish
  ##temp_all <- merge(x = x3, y = x4, all = TRUE)
  #must be un-commented for groups of 4 fish
  ##temp_all <- merge(x = temp_all, y = x5, all = TRUE)
  
  ##i = i+1
}
```
