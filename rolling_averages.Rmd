---
title: "Fluctuating Turbidity Rolling Averages"
author: "Hannah Anderson"
date: "2023-01-30"
output: pdf_document
---

## Intro

This document goes hand in hand with the RMarkdown file "Fluctuating Turbidity
Data Conversion" (fluctuating_turbidity_data_conversion.Rmd). It will
eventually become a part of that file, but for troubleshooting's sake I will
be working on them separately for now.

## Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#setting the working directory
knitr::opts_knit$set(root.dir = "D://2 Day Mini Kaolin Turb Flux Experiment/testing")
#library(plyr)
library(tidyverse)
library(data.table)
#the number of fish per group
fish = 4

```

## Reading in the files

```{r file read in, include = FALSE, message = FALSE}
#reading in the file names into a list
filelist <- list.files(pattern = "*.csv")
#from list of files, creating a list of dataframes from each file
#excluding the columns that are either empty or don't contain data we're using
fishlist <- lapply(filelist, read_csv, col_select = c(3:4, 6:8))
#replacing the inf TRex uses in place of NAs with NAs
Inf2NA <- function(v) replace(v, is.infinite(v), NA)
fishlist <- lapply(fishlist, function(d) replace(d, TRUE, sapply(d, Inf2NA)))
#colnames(workframe) <- c("tankID", "recording", "rolling_speed")
```

## Processing the files

```{r loop, include = FALSE, message = FALSE}

i = 1
for (k in 1:(length(filelist)/fish)) {
  fourfish <- fishlist[i:(i+(fish-1))]
  i = i+fish
  #determining the last frame of a video by taking the largest frame value
  #from all of the fish datafiles
  maxframe <- max(fourfish[[1]][,"frame"])
  
  #creating a dataframe with as many frames as the processed video and filling
  #all non-frame columns with NAs
  dfNA <- data.frame(frame = 0:maxframe, fish_detected = NA, angle = NA,
                     X = NA, Y = NA)

  for (z in 1:fish) {
    #finding the frame the fish datafile starts on
    minfish <- min(fourfish[[z]][,"frame"])
    #adding the NA rows from dfNA to the top of a file if its "frames" column
    #starts later than frame 0
    if (minfish > 0) {
      #adding +1 to the minimum frame value because frames start at 0 in TRex
      #but rows start at 1 in R
      fourfish[[z]] <- rbind(dfNA[1:(minfish+1),], fourfish[[z]])
    }
    #finding the fame the fish datafile ends on
    maxfish <- max(fourfish[[z]][,"frame"])
    #adding the NA rows from dfNA to the bottom of a file if its "frames" column
    #ends before the end of the video (the last frame of the longest datafile)
    #+1 for the same reason as above with minimum frames, +2 to avoid
    #duplicating the last frame
    if (maxfish[z] < maxframe) {
      fourfish[[z]] <- rbind(fourfish[[z]], dfNA[(maxfish+2):(maxframe+1),])
      #test <- rbind(fourfish[[z]], dfNA[(maxfish+2):(maxframe+1),])
      
    #a for loop inside a for loop inside a for loop...
    #this is starting to feel unnecessarily complicated. Oh well.
      
    #the time step window (amount of time before and after a time step) being
    #used in the moving average
    #our videos are in ~30 frames per second (29.7 frames)
    timew = 30    #window = 1 second
    timestep = 1
    #empty dataframe to add moving average values to
    columns <- c("speed", "polarity")
    workframe <- data.frame(matrix(nrow = 0, ncol = length(columns)))
    colnames(workframe) <- columns
      
    for (t in 1:(maxframe/30)) {
    #Mistake here
    #What we need is a total distance moved across three seconds
      #That does NOT mean finding the distance between where the fish was at
      #the start of second one and where the fish was at the end of second three
      #It means finding the distance moved between every frame of those total
      #90 seconds
      #ugh
      
    #workframe[t,"speed"] <- sqrt(((fourfish[[z]][(timestep+timew),"X"]) - 
                                  #(fourfish[[z]][timestep,"X"]))^2 +
                                 #((fourfish[[z]][(timestep+timew),"Y"]) - 
                                  #(fourfish[[z]][timestep,"Y"]))^2)
    }
      
    }
  }
  
  
  
  #combining together should only be happening after all of the other steps
  #of calculating the rolling averages have already happened
  ##x4 <- merge(x  = x1, y = x2, all = TRUE)
  #must be un-commented for groups of 4 fish
  ##temp_all <- merge(x = x3, y = x4, all = TRUE)
  #must be un-commented for groups of 4 fish
  ##temp_all <- merge(x = temp_all, y = x5, all = TRUE)
  
  ##i = i+1
}
```
